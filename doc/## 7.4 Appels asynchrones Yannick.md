## 7.4 Appels asynchrones Yannick

L‚Äôapi Javascript Fetch est vraiment simple √† utiliser. Il vous suffit d‚Äôutiliser la fonction fetch() avec une url pour effectuer une requ√™te, GET par exemple. La librairie fonctionne avec des promesses, on peut donc utiliser then catch et finally.

Nous allons utiliser notre composant <code>FilterableSliceTable</code> pour faire un appel asynchrone.  
Pour la config Proxy, il s‚Äôagit juste de mettre le lien du serveur dans le package.json.

Vous retrouvez l'ensemble des services qui vous avez d√ª r√©aliser lors de la formation C# de bercy ici : [Swagger Bercy](https://bercywebapi.azurewebsites.net/swagger/index.html)

Pour avoir les tranches d'imposition par ann√©e, nous avons besoin de faire un appel au service Slices.

Utilisons comme exemple le composant <code> FilterableSliceTable </code> pr√©c√©demment d√©velopp√© dans ce dojo.

```jsx
import React, { useState } from 'react';
import { Table } from '@axa-fr/react-toolkit-all';
import { SliceYearSelect } from 'pages/Home/FilterableSliceTable/SliceYearSelect/SliceYearSelect';
import { SliceTableHeader } from 'pages/Home/FilterableSliceTable/SliceTableHeader/SliceTableHeader';
import { SliceTableRow } from 'pages/Home/FilterableSliceTable/SliceTableRow/SliceTableRow';

export const FilterableSliceTable = () => {
  const [selectedYear, setSelectedYear] = useState('2020');
  const selectedTranches = getAllTranches().find(t => t.year === selectedYear)
    .tranches;

  return (
    <section className="af-panel">
      <header className="af-panel__header">
        <SliceYearSelect
          selectedYear={selectedYear}
          setSelectedYear={setSelectedYear}
        />
      </header>
      <div className="af-panel__content">
        <Table className="af-table">
          <SliceTableHeader />
          <Table.Body>
            {selectedTranches.map(({ id, lowBorn, highBorn, rate }) => (
              <SliceTableRow
                key={id}
                lowBorn={lowBorn}
                highBorn={highBorn}
                rate={rate}
              />
            ))}
          </Table.Body>
        </Table>
      </div>
    </section>
  );
};
```

Nous allons supprimer l‚Äôappel √† la fonction <code> selectedTranches </code> pour le remplacer par la fonction Fetch. Nous connaissons d√©j√† l‚Äôann√©e s√©lectionn√©e, elle se trouve dans la variable <code> selectedYear </code>.

Comme le lien du serveur est d√©j√† renseign√© dans le proxy du package.json, il ne nous reste plus qu‚Äô√† renseigner le nom du service, c‚Äôest-√†-dire <code> Slices </code>. Pour r√©cup√©rer les donn√©es, l‚Äôappel au service se fera via un GET. L‚Äôenvoi de l‚Äôann√©e s√©lectionn√©e se fera via un param√®tre dans l‚Äôurl.

```jsx
import React, { useState, useEffect } from 'react';
import { Table } from '@axa-fr/react-toolkit-all';
import { SliceYearSelect } from 'pages/Home/FilterableSliceTable/SliceYearSelect/SliceYearSelect';
import { SliceTableHeader } from 'pages/Home/FilterableSliceTable/SliceTableHeader/SliceTableHeader';
import { SliceTableRow } from 'pages/Home/FilterableSliceTable/SliceTableRow/SliceTableRow';

export const FilterableSliceTable = () => {
  const [selectedYear, setSelectedYear] = useState('2020');
  const [selectedTranches, setSelectedTranches] = useState([]);

  useEffect(() => {
    fetch(`/Slices?year=${selectedYear}`)
      .then(response => response.json())
      .then(json => {
        setSelectedTranches(json);
      });
  });

  return (
    <section className="af-panel">
      <header className="af-panel__header">
        <SliceYearSelect
          selectedYear={selectedYear}
          setSelectedYear={setSelectedYear}
        />
      </header>
      <div className="af-panel__content">
        <Table className="af-table">
          <SliceTableHeader />
          <Table.Body>
            {selectedTranches.map(({ id, lowBorn, highBorn, rate }) => (
              <SliceTableRow
                key={id}
                lowBorn={lowBorn}
                highBorn={highBorn}
                rate={rate}
              />
            ))}
          </Table.Body>
        </Table>
      </div>
    </section>
  );
};
```

Mais avec cette m√©thode il y aura deux probl√®mes :

- Cas du re-render avec un autre composant :
  Votre application charg√©e, le <code> useEffect </code> ex√©cutera la fonction et appellera le web service. D√®s la fonction ex√©cut√©e, vous continuerez √† utiliser votre application. Quand par exemple vous allez cliquer sur le bouton <code> calculer </code>, vous allez mettre √† jour votre <code> state </code>, cela va provoquer un re-render de l‚Äôapplication et ainsi appeler √† nouveau le service.

- Cas de l‚Äôappel infini si on utilise un setter dans useEffect :
  Une fois votre application charg√©e, le <code> useEffect </code> va ex√©cuter la fonction qui appellera le web service. S‚Äôil r√©pond positivement, vous pouvez appeler votre setter pour mettre √† jour les donn√©es, dans notre cas, les tranches et leur taux d‚Äôimposition. Mais en ex√©cutant le setter, il va re-render votre composant qui r√©ex√©cutera la m√™me fonction dans le UseEffect ‚Ä¶ vous l‚Äôaurez compris cela va faire une boucle infinie.

Pour rem√©dier √† ce probl√®me, dans les deux cas, il faut utiliser le deuxi√®me param√®tre tableau de d√©pendances dans le <code> useEffect </code>. Cela va permettre d'ex√©cuter la fonction, uniquement si une des valeurs du tableau a √©t√© modifi√©e depuis l‚Äôappel pr√©c√©dent.

```jsx
useEffect(() => {
  fetch(`/Slices?year=${selectedYear}`)
    .then(response => response.json())
    .then(json => {
      setSelectedTranches(json);
    });
}, [selectedYear]);
```

Dans notre cas, si la valeur de l‚Äôann√©e s√©lectionn√©e ne change pas, alors le service ne sera pas rappel√©. Assez de th√©orie, nous allons passer √† quelques exercices üòâ

**:weight_lifting_man: Exercice 7.4.1 : Appeler le service TaxComputer**

Allez directement sur [Swagger Bercy](https://bercywebapi.azurewebsites.net/swagger/index.html). Nous retrouvons le service <code>TaxComputer</code> qui va nous permettre de calculer le montant mais aussi le taux d‚Äôimposition.

Vous allez devoir mettre en place cet appel dans le composant <code> TaxComputationForm </code>.
Pour vous aider voici un exemple de code qui permet d‚Äôappeler un service en POST .

```jsx
fetch('/NomDuService', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(/* votre input ici */),
})
  .then(response => response.json())
  .then(json => {
    /* votre code */
  });
```

Dans le premier param√®tre, vous devrez mettre le nom du service, et dans le second quelques param√®tres :

- Method : la m√©thode que vous voulez utilisez, GET, POST, PUT, DELETE‚Ä¶.
- Headers : quelques param√®tres plus techniques mais importants
- Body : l‚Äôobjet que vous voulez envoyer au service

Dans notre exercice, le service se nomme <code> TaxComputer </code>, le header reste le m√™me que dans l‚Äôexemple, et le body devra recevoir un objet comme ceci :

```jsx
    const input = {
        wage: <code> le salaire </code>,
        year: <code> ann√©e </code>,
        taxHouseholdComposition: {
        nbAdults: ‚Äúnombre adulte‚Äù,
        nbChildren: ‚Äúnombre enfant‚Äù,
        },
    };
```

On pourra r√©cup√©rer la r√©ponse du service dans le bloc then() et les donn√©es gr√¢ce √† la variable response. Dans cette derni√®re vous trouverez les donn√©es de la requ√™te HTTP, le header, le body et les param√®tres.

Vous devrez effectuer la mise √† jour des donn√©es avec votre setter dans le second bloc <code> Then </code>.
Attention, le service ne renvoie que le montant de l‚Äôimp√¥t <code> amount </code> et le taux d‚Äôimposition <code> marginalTaxRate </code>.

Pour mettre √† jour le nombre de parts, vous devez utiliser une fonction comme vous le r√©alisiez auparavant avec le computeTaxeService. Ici vous devez utiliser la fonction <code> calculNbPartsService </code>, elle re√ßoit deux param√®tres : le nombre d‚Äôadultes en premier et le nombre d‚Äôenfants en second. Respectez bien l‚Äôordre, celui-ci est tr√®s importantüòâ

**:weight_lifting_man: Exercice 7.4.2 : Mettre en place un message d‚Äôerreur**

Voil√†, vous avez appeler le service et mettre √† jour les donn√©es dans le composant !!! Mais que se passerait-il si le service renvoyait une erreur ?

Dans la plupart des applications modernes, on utilise un message d‚Äôalerte pour avertir l‚Äôutilisateur s‚Äôil manque des donn√©es dans le formulaire par exemple ou si le service est KO et nous renvoie une erreur.

L‚Äôexercice est simple, vous allez mettre en place un message d‚Äôinformation quand le service est en erreur. Pour ce faire, mettez en place le composant <code> Alert </code> du toolkit Axa dans le composant <code> TaxComputationForm </code>

```jsx
<Alert
  classModifier="error"
  title="une erreur est survenue, veuillez v√©rifier les donn√©es saisies."
/>
```

Attention √† ne pas oublier l‚Äôimport dans l‚Äôent√™te du composant. Pour afficher ou non le message d‚Äôerreur, il faudra cr√©er une variable de type booleen ainsi que son setter.

Mais comment r√©cup√©rer une erreur ? Si pour une raison X la fonction fetch retourne une erreur, on peut la r√©cup√©rer avec le bloc catch(). Dans cette fonction on obtient une variable, par exemple <code> error </code> qui permet d‚Äôobtenir des informations.

```jsx
      .catch(() => {
        /* votre code */
      })
```

Allez c‚Äôest parti, √† vos claviers ! üòâ

**:weight_lifting_man: Exercice 7.4.3 : Et ‚Ä¶. ce n‚Äôest pas fini !**

<code>Then(), Catch et finally()</code> .. Et oui, il reste encore un cas que nous allons utiliser. Quand l‚Äôutilisateur va cliquer sur le bouton "calculer", on appelle un service.

Mais visuellement pour qu‚Äôil comprenne bien que le calcul est en cours, on affiche un spinner. Un cercle qui tourne, qui s‚Äôaffiche en pleine page et qui bloque toutes autres actions de l‚Äôutilisateur. Et oui cela a aussi une fonction pratique.

Dans le toolkit Axa, il existe un loader, voici son code :

```jsx
      .catch(() => {
        /* votre code */
      })
```

N‚Äôoubliez pas d‚Äôajouter ce code CSS !!!

```css
.af-loader.af-loader--spinner.af-loader-on {
  position: fixed !important;
  z-index: 100;
}
.af-loader {
  min-height: auto !important;
}
```

Son mode de fonctionnent n‚Äôest pas des plus simples mais je vais tenter de vous l‚Äôexpliquer.
Alors pour afficher le spinner sur votre page, la props <code>mode</code> du composant doit √™tre ‚ÄòGet‚Äô, ‚ÄòPost‚Äô etc ‚Ä¶. Et pour ne plus l‚Äôafficher, ‚Äònone‚Äô. Il faudra donc cr√©er une variable avec son setter, la positionner avant le fetch avec le mode ‚ÄòPost‚Äô, et dans le bloc finally avec le <code>mode</code> ‚Äònone‚Äô.

Je compte sur vous, √† vos claviers üòä
